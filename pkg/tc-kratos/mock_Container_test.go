// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package tckratos

import (
	"context"
	"io"
	"time"

	"github.com/docker/docker/api/types/container"
	"github.com/docker/go-connections/nat"
	mock "github.com/stretchr/testify/mock"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/exec"
)

// NewMockContainer creates a new instance of MockContainer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockContainer(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockContainer {
	mock := &MockContainer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockContainer is an autogenerated mock type for the Container type
type MockContainer struct {
	mock.Mock
}

type MockContainer_Expecter struct {
	mock *mock.Mock
}

func (_m *MockContainer) EXPECT() *MockContainer_Expecter {
	return &MockContainer_Expecter{mock: &_m.Mock}
}

// ContainerIP provides a mock function for the type MockContainer
func (_mock *MockContainer) ContainerIP(context1 context.Context) (string, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for ContainerIP")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = returnFunc(context1)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainer_ContainerIP_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContainerIP'
type MockContainer_ContainerIP_Call struct {
	*mock.Call
}

// ContainerIP is a helper method to define mock.On call
//   - context1 context.Context
func (_e *MockContainer_Expecter) ContainerIP(context1 interface{}) *MockContainer_ContainerIP_Call {
	return &MockContainer_ContainerIP_Call{Call: _e.mock.On("ContainerIP", context1)}
}

func (_c *MockContainer_ContainerIP_Call) Run(run func(context1 context.Context)) *MockContainer_ContainerIP_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockContainer_ContainerIP_Call) Return(s string, err error) *MockContainer_ContainerIP_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockContainer_ContainerIP_Call) RunAndReturn(run func(context1 context.Context) (string, error)) *MockContainer_ContainerIP_Call {
	_c.Call.Return(run)
	return _c
}

// ContainerIPs provides a mock function for the type MockContainer
func (_mock *MockContainer) ContainerIPs(context1 context.Context) ([]string, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for ContainerIPs")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]string, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainer_ContainerIPs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ContainerIPs'
type MockContainer_ContainerIPs_Call struct {
	*mock.Call
}

// ContainerIPs is a helper method to define mock.On call
//   - context1 context.Context
func (_e *MockContainer_Expecter) ContainerIPs(context1 interface{}) *MockContainer_ContainerIPs_Call {
	return &MockContainer_ContainerIPs_Call{Call: _e.mock.On("ContainerIPs", context1)}
}

func (_c *MockContainer_ContainerIPs_Call) Run(run func(context1 context.Context)) *MockContainer_ContainerIPs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockContainer_ContainerIPs_Call) Return(strings []string, err error) *MockContainer_ContainerIPs_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *MockContainer_ContainerIPs_Call) RunAndReturn(run func(context1 context.Context) ([]string, error)) *MockContainer_ContainerIPs_Call {
	_c.Call.Return(run)
	return _c
}

// CopyDirToContainer provides a mock function for the type MockContainer
func (_mock *MockContainer) CopyDirToContainer(ctx context.Context, hostDirPath string, containerParentPath string, fileMode int64) error {
	ret := _mock.Called(ctx, hostDirPath, containerParentPath, fileMode)

	if len(ret) == 0 {
		panic("no return value specified for CopyDirToContainer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int64) error); ok {
		r0 = returnFunc(ctx, hostDirPath, containerParentPath, fileMode)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainer_CopyDirToContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyDirToContainer'
type MockContainer_CopyDirToContainer_Call struct {
	*mock.Call
}

// CopyDirToContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - hostDirPath string
//   - containerParentPath string
//   - fileMode int64
func (_e *MockContainer_Expecter) CopyDirToContainer(ctx interface{}, hostDirPath interface{}, containerParentPath interface{}, fileMode interface{}) *MockContainer_CopyDirToContainer_Call {
	return &MockContainer_CopyDirToContainer_Call{Call: _e.mock.On("CopyDirToContainer", ctx, hostDirPath, containerParentPath, fileMode)}
}

func (_c *MockContainer_CopyDirToContainer_Call) Run(run func(ctx context.Context, hostDirPath string, containerParentPath string, fileMode int64)) *MockContainer_CopyDirToContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int64
		if args[3] != nil {
			arg3 = args[3].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockContainer_CopyDirToContainer_Call) Return(err error) *MockContainer_CopyDirToContainer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainer_CopyDirToContainer_Call) RunAndReturn(run func(ctx context.Context, hostDirPath string, containerParentPath string, fileMode int64) error) *MockContainer_CopyDirToContainer_Call {
	_c.Call.Return(run)
	return _c
}

// CopyFileFromContainer provides a mock function for the type MockContainer
func (_mock *MockContainer) CopyFileFromContainer(ctx context.Context, filePath string) (io.ReadCloser, error) {
	ret := _mock.Called(ctx, filePath)

	if len(ret) == 0 {
		panic("no return value specified for CopyFileFromContainer")
	}

	var r0 io.ReadCloser
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (io.ReadCloser, error)); ok {
		return returnFunc(ctx, filePath)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) io.ReadCloser); ok {
		r0 = returnFunc(ctx, filePath)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, filePath)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainer_CopyFileFromContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyFileFromContainer'
type MockContainer_CopyFileFromContainer_Call struct {
	*mock.Call
}

// CopyFileFromContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - filePath string
func (_e *MockContainer_Expecter) CopyFileFromContainer(ctx interface{}, filePath interface{}) *MockContainer_CopyFileFromContainer_Call {
	return &MockContainer_CopyFileFromContainer_Call{Call: _e.mock.On("CopyFileFromContainer", ctx, filePath)}
}

func (_c *MockContainer_CopyFileFromContainer_Call) Run(run func(ctx context.Context, filePath string)) *MockContainer_CopyFileFromContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainer_CopyFileFromContainer_Call) Return(readCloser io.ReadCloser, err error) *MockContainer_CopyFileFromContainer_Call {
	_c.Call.Return(readCloser, err)
	return _c
}

func (_c *MockContainer_CopyFileFromContainer_Call) RunAndReturn(run func(ctx context.Context, filePath string) (io.ReadCloser, error)) *MockContainer_CopyFileFromContainer_Call {
	_c.Call.Return(run)
	return _c
}

// CopyFileToContainer provides a mock function for the type MockContainer
func (_mock *MockContainer) CopyFileToContainer(ctx context.Context, hostFilePath string, containerFilePath string, fileMode int64) error {
	ret := _mock.Called(ctx, hostFilePath, containerFilePath, fileMode)

	if len(ret) == 0 {
		panic("no return value specified for CopyFileToContainer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string, int64) error); ok {
		r0 = returnFunc(ctx, hostFilePath, containerFilePath, fileMode)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainer_CopyFileToContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyFileToContainer'
type MockContainer_CopyFileToContainer_Call struct {
	*mock.Call
}

// CopyFileToContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - hostFilePath string
//   - containerFilePath string
//   - fileMode int64
func (_e *MockContainer_Expecter) CopyFileToContainer(ctx interface{}, hostFilePath interface{}, containerFilePath interface{}, fileMode interface{}) *MockContainer_CopyFileToContainer_Call {
	return &MockContainer_CopyFileToContainer_Call{Call: _e.mock.On("CopyFileToContainer", ctx, hostFilePath, containerFilePath, fileMode)}
}

func (_c *MockContainer_CopyFileToContainer_Call) Run(run func(ctx context.Context, hostFilePath string, containerFilePath string, fileMode int64)) *MockContainer_CopyFileToContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int64
		if args[3] != nil {
			arg3 = args[3].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockContainer_CopyFileToContainer_Call) Return(err error) *MockContainer_CopyFileToContainer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainer_CopyFileToContainer_Call) RunAndReturn(run func(ctx context.Context, hostFilePath string, containerFilePath string, fileMode int64) error) *MockContainer_CopyFileToContainer_Call {
	_c.Call.Return(run)
	return _c
}

// CopyToContainer provides a mock function for the type MockContainer
func (_mock *MockContainer) CopyToContainer(ctx context.Context, fileContent []byte, containerFilePath string, fileMode int64) error {
	ret := _mock.Called(ctx, fileContent, containerFilePath, fileMode)

	if len(ret) == 0 {
		panic("no return value specified for CopyToContainer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []byte, string, int64) error); ok {
		r0 = returnFunc(ctx, fileContent, containerFilePath, fileMode)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainer_CopyToContainer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyToContainer'
type MockContainer_CopyToContainer_Call struct {
	*mock.Call
}

// CopyToContainer is a helper method to define mock.On call
//   - ctx context.Context
//   - fileContent []byte
//   - containerFilePath string
//   - fileMode int64
func (_e *MockContainer_Expecter) CopyToContainer(ctx interface{}, fileContent interface{}, containerFilePath interface{}, fileMode interface{}) *MockContainer_CopyToContainer_Call {
	return &MockContainer_CopyToContainer_Call{Call: _e.mock.On("CopyToContainer", ctx, fileContent, containerFilePath, fileMode)}
}

func (_c *MockContainer_CopyToContainer_Call) Run(run func(ctx context.Context, fileContent []byte, containerFilePath string, fileMode int64)) *MockContainer_CopyToContainer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []byte
		if args[1] != nil {
			arg1 = args[1].([]byte)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int64
		if args[3] != nil {
			arg3 = args[3].(int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockContainer_CopyToContainer_Call) Return(err error) *MockContainer_CopyToContainer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainer_CopyToContainer_Call) RunAndReturn(run func(ctx context.Context, fileContent []byte, containerFilePath string, fileMode int64) error) *MockContainer_CopyToContainer_Call {
	_c.Call.Return(run)
	return _c
}

// Endpoint provides a mock function for the type MockContainer
func (_mock *MockContainer) Endpoint(context1 context.Context, s string) (string, error) {
	ret := _mock.Called(context1, s)

	if len(ret) == 0 {
		panic("no return value specified for Endpoint")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return returnFunc(context1, s)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = returnFunc(context1, s)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(context1, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainer_Endpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Endpoint'
type MockContainer_Endpoint_Call struct {
	*mock.Call
}

// Endpoint is a helper method to define mock.On call
//   - context1 context.Context
//   - s string
func (_e *MockContainer_Expecter) Endpoint(context1 interface{}, s interface{}) *MockContainer_Endpoint_Call {
	return &MockContainer_Endpoint_Call{Call: _e.mock.On("Endpoint", context1, s)}
}

func (_c *MockContainer_Endpoint_Call) Run(run func(context1 context.Context, s string)) *MockContainer_Endpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainer_Endpoint_Call) Return(s1 string, err error) *MockContainer_Endpoint_Call {
	_c.Call.Return(s1, err)
	return _c
}

func (_c *MockContainer_Endpoint_Call) RunAndReturn(run func(context1 context.Context, s string) (string, error)) *MockContainer_Endpoint_Call {
	_c.Call.Return(run)
	return _c
}

// Exec provides a mock function for the type MockContainer
func (_mock *MockContainer) Exec(ctx context.Context, cmd []string, options ...exec.ProcessOption) (int, io.Reader, error) {
	var tmpRet mock.Arguments
	if len(options) > 0 {
		tmpRet = _mock.Called(ctx, cmd, options)
	} else {
		tmpRet = _mock.Called(ctx, cmd)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 int
	var r1 io.Reader
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, ...exec.ProcessOption) (int, io.Reader, error)); ok {
		return returnFunc(ctx, cmd, options...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []string, ...exec.ProcessOption) int); ok {
		r0 = returnFunc(ctx, cmd, options...)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []string, ...exec.ProcessOption) io.Reader); ok {
		r1 = returnFunc(ctx, cmd, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(io.Reader)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, []string, ...exec.ProcessOption) error); ok {
		r2 = returnFunc(ctx, cmd, options...)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockContainer_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockContainer_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - cmd []string
//   - options ...exec.ProcessOption
func (_e *MockContainer_Expecter) Exec(ctx interface{}, cmd interface{}, options ...interface{}) *MockContainer_Exec_Call {
	return &MockContainer_Exec_Call{Call: _e.mock.On("Exec",
		append([]interface{}{ctx, cmd}, options...)...)}
}

func (_c *MockContainer_Exec_Call) Run(run func(ctx context.Context, cmd []string, options ...exec.ProcessOption)) *MockContainer_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []string
		if args[1] != nil {
			arg1 = args[1].([]string)
		}
		var arg2 []exec.ProcessOption
		var variadicArgs []exec.ProcessOption
		if len(args) > 2 {
			variadicArgs = args[2].([]exec.ProcessOption)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockContainer_Exec_Call) Return(n int, reader io.Reader, err error) *MockContainer_Exec_Call {
	_c.Call.Return(n, reader, err)
	return _c
}

func (_c *MockContainer_Exec_Call) RunAndReturn(run func(ctx context.Context, cmd []string, options ...exec.ProcessOption) (int, io.Reader, error)) *MockContainer_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// FollowOutput provides a mock function for the type MockContainer
func (_mock *MockContainer) FollowOutput(logConsumer testcontainers.LogConsumer) {
	_mock.Called(logConsumer)
	return
}

// MockContainer_FollowOutput_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FollowOutput'
type MockContainer_FollowOutput_Call struct {
	*mock.Call
}

// FollowOutput is a helper method to define mock.On call
//   - logConsumer testcontainers.LogConsumer
func (_e *MockContainer_Expecter) FollowOutput(logConsumer interface{}) *MockContainer_FollowOutput_Call {
	return &MockContainer_FollowOutput_Call{Call: _e.mock.On("FollowOutput", logConsumer)}
}

func (_c *MockContainer_FollowOutput_Call) Run(run func(logConsumer testcontainers.LogConsumer)) *MockContainer_FollowOutput_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 testcontainers.LogConsumer
		if args[0] != nil {
			arg0 = args[0].(testcontainers.LogConsumer)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockContainer_FollowOutput_Call) Return() *MockContainer_FollowOutput_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockContainer_FollowOutput_Call) RunAndReturn(run func(logConsumer testcontainers.LogConsumer)) *MockContainer_FollowOutput_Call {
	_c.Run(run)
	return _c
}

// GetContainerID provides a mock function for the type MockContainer
func (_mock *MockContainer) GetContainerID() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetContainerID")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockContainer_GetContainerID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetContainerID'
type MockContainer_GetContainerID_Call struct {
	*mock.Call
}

// GetContainerID is a helper method to define mock.On call
func (_e *MockContainer_Expecter) GetContainerID() *MockContainer_GetContainerID_Call {
	return &MockContainer_GetContainerID_Call{Call: _e.mock.On("GetContainerID")}
}

func (_c *MockContainer_GetContainerID_Call) Run(run func()) *MockContainer_GetContainerID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockContainer_GetContainerID_Call) Return(s string) *MockContainer_GetContainerID_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockContainer_GetContainerID_Call) RunAndReturn(run func() string) *MockContainer_GetContainerID_Call {
	_c.Call.Return(run)
	return _c
}

// GetLogProductionErrorChannel provides a mock function for the type MockContainer
func (_mock *MockContainer) GetLogProductionErrorChannel() <-chan error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetLogProductionErrorChannel")
	}

	var r0 <-chan error
	if returnFunc, ok := ret.Get(0).(func() <-chan error); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan error)
		}
	}
	return r0
}

// MockContainer_GetLogProductionErrorChannel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLogProductionErrorChannel'
type MockContainer_GetLogProductionErrorChannel_Call struct {
	*mock.Call
}

// GetLogProductionErrorChannel is a helper method to define mock.On call
func (_e *MockContainer_Expecter) GetLogProductionErrorChannel() *MockContainer_GetLogProductionErrorChannel_Call {
	return &MockContainer_GetLogProductionErrorChannel_Call{Call: _e.mock.On("GetLogProductionErrorChannel")}
}

func (_c *MockContainer_GetLogProductionErrorChannel_Call) Run(run func()) *MockContainer_GetLogProductionErrorChannel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockContainer_GetLogProductionErrorChannel_Call) Return(errCh <-chan error) *MockContainer_GetLogProductionErrorChannel_Call {
	_c.Call.Return(errCh)
	return _c
}

func (_c *MockContainer_GetLogProductionErrorChannel_Call) RunAndReturn(run func() <-chan error) *MockContainer_GetLogProductionErrorChannel_Call {
	_c.Call.Return(run)
	return _c
}

// Host provides a mock function for the type MockContainer
func (_mock *MockContainer) Host(context1 context.Context) (string, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Host")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = returnFunc(context1)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainer_Host_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Host'
type MockContainer_Host_Call struct {
	*mock.Call
}

// Host is a helper method to define mock.On call
//   - context1 context.Context
func (_e *MockContainer_Expecter) Host(context1 interface{}) *MockContainer_Host_Call {
	return &MockContainer_Host_Call{Call: _e.mock.On("Host", context1)}
}

func (_c *MockContainer_Host_Call) Run(run func(context1 context.Context)) *MockContainer_Host_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockContainer_Host_Call) Return(s string, err error) *MockContainer_Host_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockContainer_Host_Call) RunAndReturn(run func(context1 context.Context) (string, error)) *MockContainer_Host_Call {
	_c.Call.Return(run)
	return _c
}

// Inspect provides a mock function for the type MockContainer
func (_mock *MockContainer) Inspect(context1 context.Context) (*container.InspectResponse, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Inspect")
	}

	var r0 *container.InspectResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*container.InspectResponse, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *container.InspectResponse); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*container.InspectResponse)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainer_Inspect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Inspect'
type MockContainer_Inspect_Call struct {
	*mock.Call
}

// Inspect is a helper method to define mock.On call
//   - context1 context.Context
func (_e *MockContainer_Expecter) Inspect(context1 interface{}) *MockContainer_Inspect_Call {
	return &MockContainer_Inspect_Call{Call: _e.mock.On("Inspect", context1)}
}

func (_c *MockContainer_Inspect_Call) Run(run func(context1 context.Context)) *MockContainer_Inspect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockContainer_Inspect_Call) Return(inspectResponse *container.InspectResponse, err error) *MockContainer_Inspect_Call {
	_c.Call.Return(inspectResponse, err)
	return _c
}

func (_c *MockContainer_Inspect_Call) RunAndReturn(run func(context1 context.Context) (*container.InspectResponse, error)) *MockContainer_Inspect_Call {
	_c.Call.Return(run)
	return _c
}

// IsRunning provides a mock function for the type MockContainer
func (_mock *MockContainer) IsRunning() bool {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsRunning")
	}

	var r0 bool
	if returnFunc, ok := ret.Get(0).(func() bool); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(bool)
	}
	return r0
}

// MockContainer_IsRunning_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsRunning'
type MockContainer_IsRunning_Call struct {
	*mock.Call
}

// IsRunning is a helper method to define mock.On call
func (_e *MockContainer_Expecter) IsRunning() *MockContainer_IsRunning_Call {
	return &MockContainer_IsRunning_Call{Call: _e.mock.On("IsRunning")}
}

func (_c *MockContainer_IsRunning_Call) Run(run func()) *MockContainer_IsRunning_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockContainer_IsRunning_Call) Return(b bool) *MockContainer_IsRunning_Call {
	_c.Call.Return(b)
	return _c
}

func (_c *MockContainer_IsRunning_Call) RunAndReturn(run func() bool) *MockContainer_IsRunning_Call {
	_c.Call.Return(run)
	return _c
}

// Logs provides a mock function for the type MockContainer
func (_mock *MockContainer) Logs(context1 context.Context) (io.ReadCloser, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Logs")
	}

	var r0 io.ReadCloser
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (io.ReadCloser, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) io.ReadCloser); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.ReadCloser)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainer_Logs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Logs'
type MockContainer_Logs_Call struct {
	*mock.Call
}

// Logs is a helper method to define mock.On call
//   - context1 context.Context
func (_e *MockContainer_Expecter) Logs(context1 interface{}) *MockContainer_Logs_Call {
	return &MockContainer_Logs_Call{Call: _e.mock.On("Logs", context1)}
}

func (_c *MockContainer_Logs_Call) Run(run func(context1 context.Context)) *MockContainer_Logs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockContainer_Logs_Call) Return(readCloser io.ReadCloser, err error) *MockContainer_Logs_Call {
	_c.Call.Return(readCloser, err)
	return _c
}

func (_c *MockContainer_Logs_Call) RunAndReturn(run func(context1 context.Context) (io.ReadCloser, error)) *MockContainer_Logs_Call {
	_c.Call.Return(run)
	return _c
}

// MappedPort provides a mock function for the type MockContainer
func (_mock *MockContainer) MappedPort(context1 context.Context, port nat.Port) (nat.Port, error) {
	ret := _mock.Called(context1, port)

	if len(ret) == 0 {
		panic("no return value specified for MappedPort")
	}

	var r0 nat.Port
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, nat.Port) (nat.Port, error)); ok {
		return returnFunc(context1, port)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, nat.Port) nat.Port); ok {
		r0 = returnFunc(context1, port)
	} else {
		r0 = ret.Get(0).(nat.Port)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, nat.Port) error); ok {
		r1 = returnFunc(context1, port)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainer_MappedPort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MappedPort'
type MockContainer_MappedPort_Call struct {
	*mock.Call
}

// MappedPort is a helper method to define mock.On call
//   - context1 context.Context
//   - port nat.Port
func (_e *MockContainer_Expecter) MappedPort(context1 interface{}, port interface{}) *MockContainer_MappedPort_Call {
	return &MockContainer_MappedPort_Call{Call: _e.mock.On("MappedPort", context1, port)}
}

func (_c *MockContainer_MappedPort_Call) Run(run func(context1 context.Context, port nat.Port)) *MockContainer_MappedPort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 nat.Port
		if args[1] != nil {
			arg1 = args[1].(nat.Port)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainer_MappedPort_Call) Return(port1 nat.Port, err error) *MockContainer_MappedPort_Call {
	_c.Call.Return(port1, err)
	return _c
}

func (_c *MockContainer_MappedPort_Call) RunAndReturn(run func(context1 context.Context, port nat.Port) (nat.Port, error)) *MockContainer_MappedPort_Call {
	_c.Call.Return(run)
	return _c
}

// Name provides a mock function for the type MockContainer
func (_mock *MockContainer) Name(context1 context.Context) (string, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = returnFunc(context1)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainer_Name_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Name'
type MockContainer_Name_Call struct {
	*mock.Call
}

// Name is a helper method to define mock.On call
//   - context1 context.Context
func (_e *MockContainer_Expecter) Name(context1 interface{}) *MockContainer_Name_Call {
	return &MockContainer_Name_Call{Call: _e.mock.On("Name", context1)}
}

func (_c *MockContainer_Name_Call) Run(run func(context1 context.Context)) *MockContainer_Name_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockContainer_Name_Call) Return(s string, err error) *MockContainer_Name_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockContainer_Name_Call) RunAndReturn(run func(context1 context.Context) (string, error)) *MockContainer_Name_Call {
	_c.Call.Return(run)
	return _c
}

// NetworkAliases provides a mock function for the type MockContainer
func (_mock *MockContainer) NetworkAliases(context1 context.Context) (map[string][]string, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for NetworkAliases")
	}

	var r0 map[string][]string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (map[string][]string, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) map[string][]string); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainer_NetworkAliases_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetworkAliases'
type MockContainer_NetworkAliases_Call struct {
	*mock.Call
}

// NetworkAliases is a helper method to define mock.On call
//   - context1 context.Context
func (_e *MockContainer_Expecter) NetworkAliases(context1 interface{}) *MockContainer_NetworkAliases_Call {
	return &MockContainer_NetworkAliases_Call{Call: _e.mock.On("NetworkAliases", context1)}
}

func (_c *MockContainer_NetworkAliases_Call) Run(run func(context1 context.Context)) *MockContainer_NetworkAliases_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockContainer_NetworkAliases_Call) Return(stringToStrings map[string][]string, err error) *MockContainer_NetworkAliases_Call {
	_c.Call.Return(stringToStrings, err)
	return _c
}

func (_c *MockContainer_NetworkAliases_Call) RunAndReturn(run func(context1 context.Context) (map[string][]string, error)) *MockContainer_NetworkAliases_Call {
	_c.Call.Return(run)
	return _c
}

// Networks provides a mock function for the type MockContainer
func (_mock *MockContainer) Networks(context1 context.Context) ([]string, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Networks")
	}

	var r0 []string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]string, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []string); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainer_Networks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Networks'
type MockContainer_Networks_Call struct {
	*mock.Call
}

// Networks is a helper method to define mock.On call
//   - context1 context.Context
func (_e *MockContainer_Expecter) Networks(context1 interface{}) *MockContainer_Networks_Call {
	return &MockContainer_Networks_Call{Call: _e.mock.On("Networks", context1)}
}

func (_c *MockContainer_Networks_Call) Run(run func(context1 context.Context)) *MockContainer_Networks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockContainer_Networks_Call) Return(strings []string, err error) *MockContainer_Networks_Call {
	_c.Call.Return(strings, err)
	return _c
}

func (_c *MockContainer_Networks_Call) RunAndReturn(run func(context1 context.Context) ([]string, error)) *MockContainer_Networks_Call {
	_c.Call.Return(run)
	return _c
}

// PortEndpoint provides a mock function for the type MockContainer
func (_mock *MockContainer) PortEndpoint(ctx context.Context, port nat.Port, proto string) (string, error) {
	ret := _mock.Called(ctx, port, proto)

	if len(ret) == 0 {
		panic("no return value specified for PortEndpoint")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, nat.Port, string) (string, error)); ok {
		return returnFunc(ctx, port, proto)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, nat.Port, string) string); ok {
		r0 = returnFunc(ctx, port, proto)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, nat.Port, string) error); ok {
		r1 = returnFunc(ctx, port, proto)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainer_PortEndpoint_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PortEndpoint'
type MockContainer_PortEndpoint_Call struct {
	*mock.Call
}

// PortEndpoint is a helper method to define mock.On call
//   - ctx context.Context
//   - port nat.Port
//   - proto string
func (_e *MockContainer_Expecter) PortEndpoint(ctx interface{}, port interface{}, proto interface{}) *MockContainer_PortEndpoint_Call {
	return &MockContainer_PortEndpoint_Call{Call: _e.mock.On("PortEndpoint", ctx, port, proto)}
}

func (_c *MockContainer_PortEndpoint_Call) Run(run func(ctx context.Context, port nat.Port, proto string)) *MockContainer_PortEndpoint_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 nat.Port
		if args[1] != nil {
			arg1 = args[1].(nat.Port)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockContainer_PortEndpoint_Call) Return(s string, err error) *MockContainer_PortEndpoint_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockContainer_PortEndpoint_Call) RunAndReturn(run func(ctx context.Context, port nat.Port, proto string) (string, error)) *MockContainer_PortEndpoint_Call {
	_c.Call.Return(run)
	return _c
}

// Ports provides a mock function for the type MockContainer
func (_mock *MockContainer) Ports(context1 context.Context) (nat.PortMap, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Ports")
	}

	var r0 nat.PortMap
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (nat.PortMap, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) nat.PortMap); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(nat.PortMap)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainer_Ports_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ports'
type MockContainer_Ports_Call struct {
	*mock.Call
}

// Ports is a helper method to define mock.On call
//   - context1 context.Context
func (_e *MockContainer_Expecter) Ports(context1 interface{}) *MockContainer_Ports_Call {
	return &MockContainer_Ports_Call{Call: _e.mock.On("Ports", context1)}
}

func (_c *MockContainer_Ports_Call) Run(run func(context1 context.Context)) *MockContainer_Ports_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockContainer_Ports_Call) Return(portMap nat.PortMap, err error) *MockContainer_Ports_Call {
	_c.Call.Return(portMap, err)
	return _c
}

func (_c *MockContainer_Ports_Call) RunAndReturn(run func(context1 context.Context) (nat.PortMap, error)) *MockContainer_Ports_Call {
	_c.Call.Return(run)
	return _c
}

// SessionID provides a mock function for the type MockContainer
func (_mock *MockContainer) SessionID() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for SessionID")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockContainer_SessionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SessionID'
type MockContainer_SessionID_Call struct {
	*mock.Call
}

// SessionID is a helper method to define mock.On call
func (_e *MockContainer_Expecter) SessionID() *MockContainer_SessionID_Call {
	return &MockContainer_SessionID_Call{Call: _e.mock.On("SessionID")}
}

func (_c *MockContainer_SessionID_Call) Run(run func()) *MockContainer_SessionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockContainer_SessionID_Call) Return(s string) *MockContainer_SessionID_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockContainer_SessionID_Call) RunAndReturn(run func() string) *MockContainer_SessionID_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function for the type MockContainer
func (_mock *MockContainer) Start(context1 context.Context) error {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(context1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainer_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type MockContainer_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
//   - context1 context.Context
func (_e *MockContainer_Expecter) Start(context1 interface{}) *MockContainer_Start_Call {
	return &MockContainer_Start_Call{Call: _e.mock.On("Start", context1)}
}

func (_c *MockContainer_Start_Call) Run(run func(context1 context.Context)) *MockContainer_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockContainer_Start_Call) Return(err error) *MockContainer_Start_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainer_Start_Call) RunAndReturn(run func(context1 context.Context) error) *MockContainer_Start_Call {
	_c.Call.Return(run)
	return _c
}

// StartLogProducer provides a mock function for the type MockContainer
func (_mock *MockContainer) StartLogProducer(context1 context.Context, logProductionOptions ...testcontainers.LogProductionOption) error {
	var tmpRet mock.Arguments
	if len(logProductionOptions) > 0 {
		tmpRet = _mock.Called(context1, logProductionOptions)
	} else {
		tmpRet = _mock.Called(context1)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for StartLogProducer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...testcontainers.LogProductionOption) error); ok {
		r0 = returnFunc(context1, logProductionOptions...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainer_StartLogProducer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartLogProducer'
type MockContainer_StartLogProducer_Call struct {
	*mock.Call
}

// StartLogProducer is a helper method to define mock.On call
//   - context1 context.Context
//   - logProductionOptions ...testcontainers.LogProductionOption
func (_e *MockContainer_Expecter) StartLogProducer(context1 interface{}, logProductionOptions ...interface{}) *MockContainer_StartLogProducer_Call {
	return &MockContainer_StartLogProducer_Call{Call: _e.mock.On("StartLogProducer",
		append([]interface{}{context1}, logProductionOptions...)...)}
}

func (_c *MockContainer_StartLogProducer_Call) Run(run func(context1 context.Context, logProductionOptions ...testcontainers.LogProductionOption)) *MockContainer_StartLogProducer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []testcontainers.LogProductionOption
		var variadicArgs []testcontainers.LogProductionOption
		if len(args) > 1 {
			variadicArgs = args[1].([]testcontainers.LogProductionOption)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockContainer_StartLogProducer_Call) Return(err error) *MockContainer_StartLogProducer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainer_StartLogProducer_Call) RunAndReturn(run func(context1 context.Context, logProductionOptions ...testcontainers.LogProductionOption) error) *MockContainer_StartLogProducer_Call {
	_c.Call.Return(run)
	return _c
}

// State provides a mock function for the type MockContainer
func (_mock *MockContainer) State(context1 context.Context) (*container.State, error) {
	ret := _mock.Called(context1)

	if len(ret) == 0 {
		panic("no return value specified for State")
	}

	var r0 *container.State
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (*container.State, error)); ok {
		return returnFunc(context1)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) *container.State); ok {
		r0 = returnFunc(context1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*container.State)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(context1)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockContainer_State_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'State'
type MockContainer_State_Call struct {
	*mock.Call
}

// State is a helper method to define mock.On call
//   - context1 context.Context
func (_e *MockContainer_Expecter) State(context1 interface{}) *MockContainer_State_Call {
	return &MockContainer_State_Call{Call: _e.mock.On("State", context1)}
}

func (_c *MockContainer_State_Call) Run(run func(context1 context.Context)) *MockContainer_State_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockContainer_State_Call) Return(state *container.State, err error) *MockContainer_State_Call {
	_c.Call.Return(state, err)
	return _c
}

func (_c *MockContainer_State_Call) RunAndReturn(run func(context1 context.Context) (*container.State, error)) *MockContainer_State_Call {
	_c.Call.Return(run)
	return _c
}

// Stop provides a mock function for the type MockContainer
func (_mock *MockContainer) Stop(context1 context.Context, duration *time.Duration) error {
	ret := _mock.Called(context1, duration)

	if len(ret) == 0 {
		panic("no return value specified for Stop")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *time.Duration) error); ok {
		r0 = returnFunc(context1, duration)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainer_Stop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stop'
type MockContainer_Stop_Call struct {
	*mock.Call
}

// Stop is a helper method to define mock.On call
//   - context1 context.Context
//   - duration *time.Duration
func (_e *MockContainer_Expecter) Stop(context1 interface{}, duration interface{}) *MockContainer_Stop_Call {
	return &MockContainer_Stop_Call{Call: _e.mock.On("Stop", context1, duration)}
}

func (_c *MockContainer_Stop_Call) Run(run func(context1 context.Context, duration *time.Duration)) *MockContainer_Stop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *time.Duration
		if args[1] != nil {
			arg1 = args[1].(*time.Duration)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockContainer_Stop_Call) Return(err error) *MockContainer_Stop_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainer_Stop_Call) RunAndReturn(run func(context1 context.Context, duration *time.Duration) error) *MockContainer_Stop_Call {
	_c.Call.Return(run)
	return _c
}

// StopLogProducer provides a mock function for the type MockContainer
func (_mock *MockContainer) StopLogProducer() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for StopLogProducer")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainer_StopLogProducer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StopLogProducer'
type MockContainer_StopLogProducer_Call struct {
	*mock.Call
}

// StopLogProducer is a helper method to define mock.On call
func (_e *MockContainer_Expecter) StopLogProducer() *MockContainer_StopLogProducer_Call {
	return &MockContainer_StopLogProducer_Call{Call: _e.mock.On("StopLogProducer")}
}

func (_c *MockContainer_StopLogProducer_Call) Run(run func()) *MockContainer_StopLogProducer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockContainer_StopLogProducer_Call) Return(err error) *MockContainer_StopLogProducer_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainer_StopLogProducer_Call) RunAndReturn(run func() error) *MockContainer_StopLogProducer_Call {
	_c.Call.Return(run)
	return _c
}

// Terminate provides a mock function for the type MockContainer
func (_mock *MockContainer) Terminate(ctx context.Context, opts ...testcontainers.TerminateOption) error {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, opts)
	} else {
		tmpRet = _mock.Called(ctx)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Terminate")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...testcontainers.TerminateOption) error); ok {
		r0 = returnFunc(ctx, opts...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockContainer_Terminate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Terminate'
type MockContainer_Terminate_Call struct {
	*mock.Call
}

// Terminate is a helper method to define mock.On call
//   - ctx context.Context
//   - opts ...testcontainers.TerminateOption
func (_e *MockContainer_Expecter) Terminate(ctx interface{}, opts ...interface{}) *MockContainer_Terminate_Call {
	return &MockContainer_Terminate_Call{Call: _e.mock.On("Terminate",
		append([]interface{}{ctx}, opts...)...)}
}

func (_c *MockContainer_Terminate_Call) Run(run func(ctx context.Context, opts ...testcontainers.TerminateOption)) *MockContainer_Terminate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []testcontainers.TerminateOption
		var variadicArgs []testcontainers.TerminateOption
		if len(args) > 1 {
			variadicArgs = args[1].([]testcontainers.TerminateOption)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockContainer_Terminate_Call) Return(err error) *MockContainer_Terminate_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockContainer_Terminate_Call) RunAndReturn(run func(ctx context.Context, opts ...testcontainers.TerminateOption) error) *MockContainer_Terminate_Call {
	_c.Call.Return(run)
	return _c
}
